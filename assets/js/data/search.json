[ { "title": "A Docker-based development environment for Jekyll", "url": "/posts/a-docker-based-dev-environment-for-jekyll/", "categories": "", "tags": "Docker, Jekyll", "date": "2023-07-20 00:00:00 +0200", "snippet": "AbstractBeing a sofware engineer working with different projects made with different technologies,I often found myself in need of switching between multiple versions of the same build tool orapplyi...", "content": "AbstractBeing a sofware engineer working with different projects made with different technologies,I often found myself in need of switching between multiple versions of the same build tool orapplying different configurations.Rather than provisioning my computer with different versions and different configurations, I found it handy to rely on Docker containers, which can be used to build and run localprojects.That’s particulary true for cases like Jekyll websites built on a Mac. Apple already provides a Ruby version which is not ready to build Jekyll projects, andif you add the fact that sometimes you can’t run commands as root user, here is when a Docker container can save your day.The basic approach consists in providing your project with a script to be sourced, whichconfigures the shell with the proper environemnt variables and aliases to override defaultbuild tools with the ones provided the the Docker image.What is JekyllJekyll is one of many static website generators.There are cases in which you can’t or don’t want to use server-side solutions to run a website and you prefer a static set of webpages.Jekyll adds “dynamicity” to your static website by rendering HTML and Markdown files while adding them pre-defined templates.Jekyll is written in Ruby, and it needs a properly configured Ruby environment to run.How to build and run a Jekyll website with DockerRather than configuring your machine with proper Ruby and Ruby gems versions,the idea is to use to official Ruby image,and define shell aliases which hide existing binaries and use the one contained in the Docker container.See the following example to understand how I “override” the existing Ruby executable in my Mac machine with the one provided by the official Ruby Docker image:❯ which ruby/usr/bin/ruby❯ ruby -vruby 2.6.10p210 (2022-04-12 revision 67958) [universal.x86_64-darwin22]❯ alias ruby='docker run -it ruby:3.2.2 ruby'❯ which rubyruby: aliased to docker run -it ruby:3.2.2 ruby❯ ruby -vruby 3.2.2 (2023-03-30 revision e51014f9c0) [x86_64-linux]As you can see, my Mac already has a Ruby executable in /usr/bin/ruby, which provides the version 2.6.10p210 of the interpreter. But after I defined an alias with the very same nameand used it to run the ruby executable provided with the Docker image, the reported version haschanged to 3.2.2.Great, so let’s create our dev-setup.sh script with the ruby alias along with all the othercommands we need to work on a Jekyll website.❯ ls -l1GemfileGemfile.lockLICENSE_config.ymldev-setup.shsrc❯ cat dev-setup.shalias ruby='docker run -it ruby:3.2.2 ruby'alias gem='docker run -it ruby:3.2.2 gem'alias bundle='docker run -it ruby:3.2.2 bundle'alias jekyll='docker run -it ruby:3.2.2 jekyll'❯ source dev-setup.shBut what happens if we build our Jekyll website?&gt; jekyll builddocker: Error response from daemon: failed to create task for container: failed to create shim task: OCI runtime create failed: runc create failed: unable to start container process: exec: \"jekyll\": executable file not found in $PATH: unknown.ERRO[0000] error waiting for container:Right, the base Ruby Docker image does not contain the Jekyll dependency that is defined in the project’s Gemfile, we need to run bundle.&gt; bundleCould not locate GemfileStill no luck, what’s happening? The answer is very simple actually: the Docker container has no visibility on project files, hence we need to mount the project directory (which is the current working path)as a Docker volume. Since the aliases are getting quire long, let me also refactor the scriptfor better understanting.&gt;cat dev-setup.shRUBY_DOCKER_IMAGE='ruby:3.2.2'function ruby-on-docker() { echo \"Ruby Docker Wrapper\" container_command=\"$@\" docker run -it \\ -v ${PWD}:/app \\ $RUBY_DOCKER_IMAGE \\ bash -c \"cd /app; $container_command\"}alias ruby=\"ruby-on-docker ruby\"alias gem=\"ruby-on-docker gem\"alias bundle=\"ruby-on-docker bundle\"alias jekyll=\"ruby-on-docker jekyll\"Now, we need to source dev-setup.sh again and it’ll work:❯ source dev-setup.sh❯ bundleRuby Docker WrapperFetching gem metadata from https://rubygems.org/.........Fetching concurrent-ruby 1.2.2Fetching minitest 5.18.1Installing minitest 5.18.1Installing concurrent-ruby 1.2.2...Installing jekyll-sitemap 1.4.0Bundle complete! 5 Gemfile dependencies, 40 gems now installed.Use `bundle info [gemname]` to see where a bundled gem is installed.Post-install message from html-pipeline:-------------------------------------------------Thank you for installing html-pipeline!You must bundle Filter gem dependencies.See html-pipeline README.md for more details.https://github.com/jch/html-pipeline#dependencies-------------------------------------------------Now that all the project dependencies have been downloaded, we are able to run jekyll to build the side, aren’t we?&gt; jekyll builddocker: Error response from daemon: failed to create task for container: failed to create shim task: OCI runtime create failed: runc create failed: unable to start container process: exec: \"jekyll\": executable file not found in $PATH: unknown.ERRO[0000] error waiting for container:The same error again! And, again, we need a Docker volume!Ruby gems are not downloaded in the project directory (as it happens for NodeJs projects).They’re collected into a system folder, ready to be shared with other builds and other projects (as it happens with Maven projects).Let’s modify dev-setup.sh.RUBY_DOCKER_IMAGE='ruby:3.2.2'function ruby-on-docker() { echo \"Ruby Docker Wrapper\" container_command=\"$@\" docker run -it \\ -v ${PWD}:/app \\ -v ruby-gems:/usr/local/bundle \\ $RUBY_DOCKER_IMAGE \\ bash -c \"cd /app; $container_command\"}alias ruby=\"ruby-on-docker ruby\"alias gem=\"ruby-on-docker gem\"alias bundle=\"ruby-on-docker bundle\"alias jekyll=\"ruby-on-docker jekyll\"In this case, we don’t need to map Docker volume to any host directory, we can just give in a name for convenience, in this case “ruby-bundle”.At this point, we can finally run bundle once again to collect dependencies and then run jekyll.❯ source dev-setup.sh❯ bundleRuby Docker WrapperFetching gem metadata from https://rubygems.org/.........Fetching concurrent-ruby 1.2.2Fetching minitest 5.18.1Installing minitest 5.18.1Installing concurrent-ruby 1.2.2...Installing jekyll-sitemap 1.4.0Bundle complete! 5 Gemfile dependencies, 40 gems now installed.Use `bundle info [gemname]` to see where a bundled gem is installed.Post-install message from html-pipeline:-------------------------------------------------Thank you for installing html-pipeline!You must bundle Filter gem dependencies.See html-pipeline README.md for more details.https://github.com/jch/html-pipeline#dependencies-------------------------------------------------❯ jekyll -vRuby Docker Wrapperjekyll 4.3.2And also the Jekyll build is correctly created:❯ jekyll buildRuby Docker WrapperConfiguration file: /app/_config.yml Source: /app/src Destination: /app/_site Incremental build: disabled. Enable with --incremental Generating... done in 0.922 seconds. Auto-regeneration: disabled. Use --watch to enable.❯ ls -l1 _siteaboutarticlesassetsindex.htmlrobots.txtsitemap.xmltagsNow we just need last few bits to make Jekyll serve our website in dev environment:&gt; cat dev-setup.shRUBY_DOCKER_IMAGE='ruby:3.2.2'export RUBY_DOCKER_PARAMS='-p 4000:4000 -p 35729:35729'function ruby-on-docker() { echo \"Ruby Docker Wrapper\" container_command=\"$@\" docker run -it \\ $(echo $RUBY_DOCKER_PARAMS) \\ -v ${PWD}:/app \\ -v ruby-bundle:/usr/local/bundle \\ $RUBY_DOCKER_IMAGE \\ bash -c \"cd /app; $container_command\"}alias ruby=\"ruby-on-docker ruby\"alias gem=\"ruby-on-docker gem\"alias bundle=\"ruby-on-docker bundle\"alias jekyll=\"ruby-on-docker jekyll\"alias jekyll-serve=\"jekyll serve --host 0.0.0.0\"The Docker container is now exposing two ports, 4000 for standard HTTP calls and 35729 for live reload. Also a new alias jekyll-serve was defined, given how jekyll serve works, we need to add the –host parameter to bind the server to any host, otherwise it wouldn’t work.❯ jekyll-serve --livereloadRuby Docker Wrapper\tConfiguration file: /app/_config.yml Source: /app/src Destination: /app/_site Incremental build: disabled. Enable with --incremental Generating... done in 1.3 seconds. Auto-regeneration: enabled for 'src'LiveReload address: http://0.0.0.0:35729 Server address: http://0.0.0.0:4000/ Server running... press ctrl-c to stop.And, finally:" } ]
