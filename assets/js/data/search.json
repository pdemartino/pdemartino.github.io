[ { "title": "A Docker-based development environment for Jekyll", "url": "/articles/2023/07/a-docker-based-dev-environment-for-jekyll/", "categories": "", "tags": "Docker, Jekyll", "date": "2023-07-20 00:00:00 +0200", "snippet": "AbstractBeing a sofware engineer working with different projects made with different technologies,I often found myself in need of switching between multiple versions of the same build tool orapplyi...", "content": "AbstractBeing a sofware engineer working with different projects made with different technologies,I often found myself in need of switching between multiple versions of the same build tool orapplying different configurations.Rather than provisioning my computer with different versions and different configurations, I found it handy to rely on Docker containers, which can be used to build and run localprojects.That’s particulary true for cases like Jekyll websites built on a Mac. Apple already provides a Ruby version which is not ready to build Jekyll projects, andif you add the fact that sometimes you can’t run commands as root user, here is when a Docker container can save your day.The basic approach consists in providing your project with a script to be sourced, whichconfigures the shell with the proper environemnt variables and aliases to override defaultbuild tools with the ones provided the the Docker image.What is JekyllJekyll is one of many static website generators.There are cases in which you can’t or don’t want to use server-side solutions to run a website and you prefer a static set of webpages.Jekyll adds “dynamicity” to your static website by rendering HTML and Markdown files while adding them pre-defined templates.Jekyll is written in Ruby, and it needs a properly configured Ruby environment to run.How to build and run a Jekyll website with DockerRather than configuring your machine with proper Ruby and Ruby gems versions,the idea is to use to official Ruby image,and define shell aliases which hide existing binaries and use the one contained in the Docker container.See the following example to understand how I “override” the existing Ruby executable in my Mac machine with the one provided by the official Ruby Docker image:❯ which ruby/usr/bin/ruby❯ ruby -vruby 2.6.10p210 (2022-04-12 revision 67958) [universal.x86_64-darwin22]❯ alias ruby='docker run -it ruby:3.2.2 ruby'❯ which rubyruby: aliased to docker run -it ruby:3.2.2 ruby❯ ruby -vruby 3.2.2 (2023-03-30 revision e51014f9c0) [x86_64-linux]As you can see, my Mac already has a Ruby executable in /usr/bin/ruby, which provides the version 2.6.10p210 of the interpreter. But after I defined an alias with the very same nameand used it to run the ruby executable provided with the Docker image, the reported version haschanged to 3.2.2.Great, so let’s create our dev-setup.sh script with the ruby alias along with all the othercommands we need to work on a Jekyll website.❯ ls -l1GemfileGemfile.lockLICENSE_config.ymldev-setup.shsrc❯ cat dev-setup.shalias ruby='docker run -it ruby:3.2.2 ruby'alias gem='docker run -it ruby:3.2.2 gem'alias bundle='docker run -it ruby:3.2.2 bundle'alias jekyll='docker run -it ruby:3.2.2 jekyll'❯ source dev-setup.shBut what happens if we build our Jekyll website?&gt; jekyll builddocker: Error response from daemon: failed to create task for container: failed to create shim task: OCI runtime create failed: runc create failed: unable to start container process: exec: \"jekyll\": executable file not found in $PATH: unknown.ERRO[0000] error waiting for container:Right, the base Ruby Docker image does not contain the Jekyll dependency that is defined in the project’s Gemfile, we need to run bundle.&gt; bundleCould not locate GemfileStill no luck, what’s happening? The answer is very simple actually: the Docker container has no visibility on project files, hence we need to mount the project directory (which is the current working path)as a Docker volume. Since the aliases are getting quire long, let me also refactor the scriptfor better understanting.&gt;cat dev-setup.shRUBY_DOCKER_IMAGE='ruby:3.2.2'function ruby-on-docker() { echo \"Ruby Docker Wrapper\" container_command=\"$@\" docker run -it \\ -v ${PWD}:/app \\ $RUBY_DOCKER_IMAGE \\ bash -c \"cd /app; $container_command\"}alias ruby=\"ruby-on-docker ruby\"alias gem=\"ruby-on-docker gem\"alias bundle=\"ruby-on-docker bundle\"alias jekyll=\"ruby-on-docker jekyll\"Now, we need to source dev-setup.sh again and it’ll work:❯ source dev-setup.sh❯ bundleRuby Docker WrapperFetching gem metadata from https://rubygems.org/.........Fetching concurrent-ruby 1.2.2Fetching minitest 5.18.1Installing minitest 5.18.1Installing concurrent-ruby 1.2.2...Installing jekyll-sitemap 1.4.0Bundle complete! 5 Gemfile dependencies, 40 gems now installed.Use `bundle info [gemname]` to see where a bundled gem is installed.Post-install message from html-pipeline:-------------------------------------------------Thank you for installing html-pipeline!You must bundle Filter gem dependencies.See html-pipeline README.md for more details.https://github.com/jch/html-pipeline#dependencies-------------------------------------------------Now that all the project dependencies have been downloaded, we are able to run jekyll to build the side, aren’t we?&gt; jekyll builddocker: Error response from daemon: failed to create task for container: failed to create shim task: OCI runtime create failed: runc create failed: unable to start container process: exec: \"jekyll\": executable file not found in $PATH: unknown.ERRO[0000] error waiting for container:The same error again! And, again, we need a Docker volume!Ruby gems are not downloaded in the project directory (as it happens for NodeJs projects).They’re collected into a system folder, ready to be shared with other builds and other projects (as it happens with Maven projects).Let’s modify dev-setup.sh.RUBY_DOCKER_IMAGE='ruby:3.2.2'function ruby-on-docker() { echo \"Ruby Docker Wrapper\" container_command=\"$@\" docker run -it \\ -v ${PWD}:/app \\ -v ruby-gems:/usr/local/bundle \\ $RUBY_DOCKER_IMAGE \\ bash -c \"cd /app; $container_command\"}alias ruby=\"ruby-on-docker ruby\"alias gem=\"ruby-on-docker gem\"alias bundle=\"ruby-on-docker bundle\"alias jekyll=\"ruby-on-docker jekyll\"In this case, we don’t need to map Docker volume to any host directory, we can just give in a name for convenience, in this case “ruby-bundle”.At this point, we can finally run bundle once again to collect dependencies and then run jekyll.❯ source dev-setup.sh❯ bundleRuby Docker WrapperFetching gem metadata from https://rubygems.org/.........Fetching concurrent-ruby 1.2.2Fetching minitest 5.18.1Installing minitest 5.18.1Installing concurrent-ruby 1.2.2...Installing jekyll-sitemap 1.4.0Bundle complete! 5 Gemfile dependencies, 40 gems now installed.Use `bundle info [gemname]` to see where a bundled gem is installed.Post-install message from html-pipeline:-------------------------------------------------Thank you for installing html-pipeline!You must bundle Filter gem dependencies.See html-pipeline README.md for more details.https://github.com/jch/html-pipeline#dependencies-------------------------------------------------❯ jekyll -vRuby Docker Wrapperjekyll 4.3.2And also the Jekyll build is correctly created:❯ jekyll buildRuby Docker WrapperConfiguration file: /app/_config.yml Source: /app/src Destination: /app/_site Incremental build: disabled. Enable with --incremental Generating... done in 0.922 seconds. Auto-regeneration: disabled. Use --watch to enable.❯ ls -l1 _siteaboutarticlesassetsindex.htmlrobots.txtsitemap.xmltagsNow we just need last few bits to make Jekyll serve our website in dev environment:&gt; cat dev-setup.shRUBY_DOCKER_IMAGE='ruby:3.2.2'export RUBY_DOCKER_PARAMS='-p 4000:4000 -p 35729:35729'function ruby-on-docker() { echo \"Ruby Docker Wrapper\" container_command=\"$@\" docker run -it \\ $(echo $RUBY_DOCKER_PARAMS) \\ -v ${PWD}:/app \\ -v ruby-bundle:/usr/local/bundle \\ $RUBY_DOCKER_IMAGE \\ bash -c \"cd /app; $container_command\"}alias ruby=\"ruby-on-docker ruby\"alias gem=\"ruby-on-docker gem\"alias bundle=\"ruby-on-docker bundle\"alias jekyll=\"ruby-on-docker jekyll\"alias jekyll-serve=\"jekyll serve --host 0.0.0.0\"The Docker container is now exposing two ports, 4000 for standard HTTP calls and 35729 for live reload. Also a new alias jekyll-serve was defined, given how jekyll serve works, we need to add the –host parameter to bind the server to any host, otherwise it wouldn’t work.❯ jekyll-serve --livereloadRuby Docker Wrapper\tConfiguration file: /app/_config.yml Source: /app/src Destination: /app/_site Incremental build: disabled. Enable with --incremental Generating... done in 1.3 seconds. Auto-regeneration: enabled for 'src'LiveReload address: http://0.0.0.0:35729 Server address: http://0.0.0.0:4000/ Server running... press ctrl-c to stop.And, finally:" }, { "title": "SpringBoot StartUp Stats - A tool to identify beans which are slowing down your application startup", "url": "/articles/2022/12/springboot-startup-stats-identify-slow-beans/", "categories": "", "tags": "Spring, Spring Boot, Performance", "date": "2022-12-01 00:00:00 +0100", "snippet": "A Spring application is basically made up of Spring beans, “wrappers” of actual Java classes that are created by Spring framework at start-up (or on request if lazy-initialized) and injected as dep...", "content": "A Spring application is basically made up of Spring beans, “wrappers” of actual Java classes that are created by Spring framework at start-up (or on request if lazy-initialized) and injected as dependency where needed. That said, the start-up procedure of a Spring Boot application can be seen as a Tree, in which the roots are some internal Spring procedures and intermediate and leaf nodes are beans initializations. If bean “A” needs bean “B” as dependency, B will be child of A and the time needed to initialize bean A will be the time needed by A itself plus the summed time of its children.Getting an insight on the start-up procedure of a Spring Boot application is actually very simple, you just need to activate the Spring Boot StartUp actuator.Once activated, the startup events will be published via the “/actuator/startup” HTTP endpoint.{ \"springBootVersion\": \"2.7.2\", \"timeline\": { \"startTime\": \"2022-12-01T10:25:47.480064631Z\", \"events\": [ { \"endTime\": \"2022-12-01T10:25:47.543243140Z\", \"duration\": \"PT0.045062101S\", \"startTime\": \"2022-12-01T10:25:47.498181039Z\", \"startupStep\": { \"name\": \"spring.boot.application.starting\", \"id\": 0, \"tags\": [ { \"key\": \"mainApplicationClass\", \"value\": \"com.pdemartino.ApplicationKt\" } ], \"parentId\": null } }, { \"endTime\": \"2022-12-01T10:25:48.690322544Z\", \"duration\": \"PT0.91235095S\", \"startTime\": \"2022-12-01T10:25:47.777971594Z\", \"startupStep\": { \"name\": \"spring.boot.application.environment-prepared\", \"id\": 1, \"tags\": [], \"parentId\": null } }, { \"endTime\": \"2022-12-01T10:25:48.925252495Z\", \"duration\": \"PT0.000187068S\", \"startTime\": \"2022-12-01T10:25:48.925065427Z\", \"startupStep\": { \"name\": \"spring.boot.application.context-prepared\", \"id\": 2, \"tags\": [], \"parentId\": null } }, { \"endTime\": \"2022-12-01T10:25:49.066986886Z\", \"duration\": \"PT0.003744429S\", \"startTime\": \"2022-12-01T10:25:49.063242457Z\", \"startupStep\": { \"name\": \"spring.boot.application.context-loaded\", \"id\": 3, \"tags\": [], \"parentId\": null } }, { \"endTime\": \"2022-12-01T10:25:49.162692120Z\", \"duration\": \"PT0.011435772S\", \"startTime\": \"2022-12-01T10:25:49.151256348Z\", \"startupStep\": { \"name\": \"spring.beans.instantiate\", \"id\": 7, \"tags\": [ { \"key\": \"beanName\", \"value\": \"org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory\" } ], \"parentId\": 6 } }, ... ] }}Every event represents a step executed during the start-up procedure, the following pieces of information are provided: startTime and endTime: timestamp when the start-up step beging and when it finishes duration: a string containing the step duration, S suffix indicates seconds while M minutes startupStep.name: a step identifier (not unique), startipStep.name = “spring.beans.instantiate” indicated the creation of a Spring bean (the name of which can be found in the “tags” array) startupStep.id: unique identifier of the start-up step, it’s not supposed to be preserved across different hosts and deployments, hence name can be used as pivot startupStep.parentId: start-up events can be seen as a tree, this field define dependencies between steps, parentId = null indicates roots of the treeThis diagram shows a simplified example of a Spring Boot application start-up procedure:Note, the duration reported by the actuator might be misleading.If you consider the example in the diagram above, you might think Bean A is time-consuming because duration reported by the actuator is 3.1 seconds,in fact that beans only takes 0.1 seconds to instantiate itself, while it waits 3 seconds for its dependencies.Even though that JSON contains all the information, the reverse relationship (child → parent) and the fact that the net duration of intermediate steps is not explicit, some post-processing is required for extracting statistics useful to understand where bottlenecks are and on which bean you should focus on.In order to extract useful (for our case) statistics out of the Startup Actuator, we used the springboot-startup-stats script(source code available on GitHub).If you’re running on Mac, you can install it by running the following commands:brew tap pdemartino/tapbrew install springboot-startup-statsIf we run the script against the startup endpoint, it will provide a tree representation of its content:$ ENDPOINT=https://localhost:8080/actuator/startup$ springboot-startup-stats --mode tree $ENDPOINTSource: https://localhost:8080/actuator/startupMode: treeOffending Threshold: 1.7976931348623157E308Tree Root: [0]spring.boot.application.starting - t:0.038712606[1]spring.boot.application.environment-prepared - t:0.765441[2]spring.boot.application.context-prepared - t:1.46107E-4[3]spring.boot.application.context-loaded - t:0.00252148[4]spring.context.refresh - t:0.3018837 - ∑t:38.849705s├──[5]spring.context.beans.post-process - t:0.020615578 - ∑t:3.4185178s│ ├──[6]...ng.beans.instantiate:org.springframework.context.annotation.internalConfigurationAnnotationProcessor - t:0.06522767 - ∑t:0.07434817s│ │ └──[7]spring.beans.instantiate:org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory - t:0.009120496│ ├──[8]spring.context.beandef-registry.post-process - t:0.04540038 - ∑t:2.6865594s│ │ └──[9]spring.context.config-classes.parse - t:2.641159│ ├──[10]spring.context.bean-factory.post-process - t:2.51665E-4│ ├──[11]spring.context.bean-factory.post-process - t:6.455E-6│ ├──[12]spring.context.bean-factory.post-process - t:9.2838705E-4 - ∑t:0.20036256s│ │ └──[13]spring.context.config-classes.enhance - t:0.19943418│ ├──[14]spring.context.bean-factory.post-process - t:4.4913E-5│ ├──[15]spring.beans.instantiate:customBean - t:0.003065169...Among other pieces of information, the output contains: the parent→children relationship (reversed if compared with Actuator output) the tree duration “∑t”, which is the same reported by the startup endpoint the net duration “t”, which indicates exactly how long that bean takes, dependencies excludedThe net duration “t” is the value we want to focus on in order to identify slow beans.What we did on the service under test was to extract the list of the steps which used to take more than 1 second to start:$ ENDPOINT=https://localhost:8080/actuator/startup$ springboot-startup-stats --mode stats --offendingThreshold 1.0 $ENDPOINTSource: https://localhost:8080/actuator/startupMode: statsOffending Threshold: 1.0Tree Root:Number of nodes: 816Number of roots: 7Number of leaves: 540Global duration: 39.693936485637096Offending nodes: 5[291]spring.beans.instantiate:beanA - t:16.057272 - ∑t:16.143324s[485]spring.beans.instantiate:beanB - t:3.2487843 - ∑t:3.419284s[287]spring.beans.instantiate:beanC - t:2.793414 - ∑t:2.8905766s[9]spring.context.config-classes.parse - t:2.641159[72]spring.beans.instantiate:beanD - t:1.8581195 - ∑t:2.7454188sGiven that output, we might want to get an insight, for example, on beanA bean and figure out why it takes 16.05 seconds to start, while its dependencies only take 0.09 seconds (∑t - t):$ ENDPOINT=https://localhost:8080/actuator/startup$ springboot-startup-stats \\&gt; --mode tree --treeRoot spring.beans.instantiate:beanA \\&gt; $ENDPOINTSource: https://localhost:8080/actuator/startupMode: treeOffending Threshold: 1.7976931348623157E308Tree Root: spring.beans.instantiate:beanA [291]spring.beans.instantiate:beanA - t:16.057272 - ∑t:16.143324s├──[292]...s.instantiate:com.pdemartino.childA - t:0.010470834└──[293]spring.beans.instantiate:com.pdemartino.childB - t:0.075581245Next step would surely be profile your application to figure out what beanA is doing during its initialization.Credits: Stopwatch photo by Tsvetoslav Hristov on Unsplash" } ]
